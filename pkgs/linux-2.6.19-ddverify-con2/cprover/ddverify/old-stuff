#!/bin/bash

    --check-bounds                      array bounds check
    --check-pointer                     pointer check
    --check-div-by-zero                 division by zero check
  
    rm -f tmp.stderr*.txt

write_tool_script() {
  local opts
  [ -z "$CHECK_BOUNDS" ] || opts="$opts --bounds-check"
  [ -z "$CHECK_POINTER" ] || opts="$opts --pointer-check"
  [ -z "$CHECK_DIV_BY_ZERO" ] || opts="$opts --div-by-zero-check"
  [ -z "$WORD_WIDTH" ] || opts="--$WORD_WIDTH"

  case $TOOL in
    satabs)
      [ -z "$MODELCHECKER" ] || opts="$opts --modelchecker $MODELCHECKER"
      opts="$opts --iterations $NUMBER_ITERATIONS"
      ;;
    cbmc|wolverine)
      [ -z "$UNWINDSET" ] || opts="$opts $UNWINDSET"
      [ -z "$UNWIND" ] || opts="$opts --unwind $UNWIND"
      [ $CBMC_SLICING -eq 0 ] || opts="$opts --slice-formula"
      ;;
  esac

  local t_src="${DRIVER_TYPE}_SOURCES"
  TMP_FILES="$TMP_FILES $OUTPUT_TOOL_FILE"
  cat > $OUTPUT_TOOL_FILE <<EOF
#!/bin/bash
/usr/bin/time -f '#STATS: cpu=%U wall=%e maxmem=%M' $TOOL \$* $opts -I ${DDV_PATH}include/ -I ${KERNEL_SRC}include/ $DEFINES \
  $OUTPUT_CC_FILE \
  $OTHER_SOURCES \
  $DDV_SOURCES ${!t_src}
EOF
  chmod a+x $OUTPUT_TOOL_FILE
}

read_output_file() {
  NUMBER_CLAIMS=0
  local ifs=$IFS
  IFS='
'
  while read line1 && read line2 && read line3 && read line4 && read line5 && read line6 ; do
    NUMBER_CLAIMS=$((NUMBER_CLAIMS + 1))
    eval CLAIM_${NUMBER_CLAIMS}_claim_id=\"$line1\"
    eval CLAIM_${NUMBER_CLAIMS}_file=\"$line2\"
    eval CLAIM_${NUMBER_CLAIMS}_line=\"$line3\"
    eval CLAIM_${NUMBER_CLAIMS}_text=\"$line4\"
    eval CLAIM_${NUMBER_CLAIMS}_claim=\"$line5\"
    [ -z "$line6" ] || die "Unexpected non-empty line $line6"
  done < .ddv_output_2
  IFS=$ifs
}

prove_claims() {
  TMP_FILES="$TMP_FILES .smv_lock cegar_tmp_abstract.warn \
    cegar_tmp_abstract.smv cegar_tmp_abstract.stats \
    cegar_tmp_abstract.out cegar_tmp_abstract.update \
    cegar_tmp_smv_out1 cegar_tmp_smv_out2"
  for i in `seq 1 $NUMBER_CLAIMS` ; do
    claim_id_var="CLAIM_${i}_claim_id"
    file_var="CLAIM_${i}_file"
    line_var="CLAIM_${i}_line"
    text_var="CLAIM_${i}_text"
    claim_var="CLAIM_${i}_claim"
    echo -n "claim $i of $NUMBER_CLAIMS (${!claim_id_var}) "
    if [ "${!claim_var}" = "TRUE" ] ; then
      echo "SUCCESSFULL 0 "
    else
      exit_code=0
      TMP_FILES="$TMP_FILES .claim_out_${!claim_id_var}"
      bash -i -c "$TIMEOUT ./ddv_$TOOL --claim ${!claim_id_var} > .claim_out_${!claim_id_var} 2>&1" || exit_code=$?
      case $exit_code in
        0)
          awk -f ${DDV_PATH}awk/get_verification_result .claim_out_${!claim_id_var}
          grep '^#STATS' .claim_out_${!claim_id_var}
          ;;
        10)
          awk -f ${DDV_PATH}awk/get_verification_result .claim_out_${!claim_id_var}
          grep '^#STATS' .claim_out_${!claim_id_var}
          mv .claim_out_${!claim_id_var} cex_log_${!claim_id_var}
          ;;
        124)
          echo "TIMEOUT"
          ;;
        *)
          if [ "$TOOL" = "satabs" -a $exit_code -eq 11 ] ; then
            echo -n "TOO_MANY_ITERATIONS "
            awk -f ${DDV_PATH}awk/get_too_many_iterations_result .claim_out_${!claim_id_var}
          else
            echo "ERROR (exit code $exit_code)"
            mv .claim_out_${!claim_id_var} err_log_${!claim_id_var}
          fi
          ;;
      esac
    fi
  done
}

run_tool() {
  echo -n "Running $TOOL .."
  exit_code=0
  TMP_FILES="$TMP_FILES .ddv_output_1"
  ./ddv_$TOOL --show-claims > .ddv_output_1 2>&1 || exit_code=$?
  if [ $exit_code -ne 0 ] && [ "$TOOL" != "satabs" -o $exit_code -ne 1 ] ; then
    echo
    cat .ddv_output_1 | grep -v '^#STATS'
    die "Could not start $TOOL"
  fi
  echo "."
  echo -n "Parsing $TOOL output .."
  TMP_FILES="$TMP_FILES .ddv_output_2"
  awk -f ${DDV_PATH}awk/convert_satabs_output .ddv_output_1 > .ddv_output_2
  echo "."
  read_output_file
  echo "$NUMBER_CLAIMS Claims"
  prove_claims
}


