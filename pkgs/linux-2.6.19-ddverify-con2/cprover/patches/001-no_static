diff -urN -xcprover cproverbm.GKAExt/drivers/block/cpqarray.c linux-2.6.19-ddverify-seq1/drivers/block/cpqarray.c
--- cproverbm.GKAExt/drivers/block/cpqarray.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/block/cpqarray.c	2011-01-12 13:39:08.000000000 +0000
@@ -65,10 +65,10 @@
 
 #define CPQARRAY_DMA_MASK	0xFFFFFFFF	/* 32 bit DMA */
 
-static int nr_ctlr;
-static ctlr_info_t *hba[MAX_CTLR];
+int nr_ctlr;
+ctlr_info_t *hba[MAX_CTLR];
 
-static int eisa[8];
+int eisa[8];
 
 #define NR_PRODUCTS ARRAY_SIZE(products)
 
@@ -76,7 +76,7 @@
  *  product = Marketing Name for the board
  *  access = Address of the struct of function pointers
  */
-static struct board_type products[] = {
+struct board_type products[] = {
 	{ 0x0040110E, "IDA",			&smart1_access },
 	{ 0x0140110E, "IDA-2",			&smart1_access },
 	{ 0x1040110E, "IAES",			&smart1_access },
@@ -95,7 +95,7 @@
 };
 
 /* define the PCI info for the PCI cards this driver can control */
-static const struct pci_device_id cpqarray_pci_device_id[] =
+const struct pci_device_id cpqarray_pci_device_id[] =
 {
 	{ PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_COMPAQ_42XX,
 		0x0E11, 0x4058, 0, 0, 0},       /* SA431 */
@@ -122,7 +122,7 @@
 
 MODULE_DEVICE_TABLE(pci, cpqarray_pci_device_id);
 
-static struct gendisk *ida_gendisk[MAX_CTLR][NWD];
+struct gendisk *ida_gendisk[MAX_CTLR][NWD];
 
 /* Debug... */
 #define DBG(s)	do { s } while(0)
@@ -133,20 +133,20 @@
 /* Debug Extra Paranoid... */
 #define DBGPX(s) do { } while(0)
 
-static int cpqarray_pci_init(ctlr_info_t *c, struct pci_dev *pdev);
-static void __iomem *remap_pci_mem(ulong base, ulong size);
-static int cpqarray_eisa_detect(void);
-static int pollcomplete(int ctlr);
-static void getgeometry(int ctlr);
-static void start_fwbk(int ctlr);
+int cpqarray_pci_init(ctlr_info_t *c, struct pci_dev *pdev);
+void __iomem *remap_pci_mem(ulong base, ulong size);
+int cpqarray_eisa_detect(void);
+int pollcomplete(int ctlr);
+void getgeometry(int ctlr);
+void start_fwbk(int ctlr);
 
-static cmdlist_t * cmd_alloc(ctlr_info_t *h, int get_from_pool);
-static void cmd_free(ctlr_info_t *h, cmdlist_t *c, int got_from_pool);
+cmdlist_t * cmd_alloc(ctlr_info_t *h, int get_from_pool);
+void cmd_free(ctlr_info_t *h, cmdlist_t *c, int got_from_pool);
 
-static void free_hba(int i);
-static int alloc_cpqarray_hba(void);
+void free_hba(int i);
+int alloc_cpqarray_hba(void);
 
-static int sendcmd(
+int sendcmd(
 	__u8	cmd,
 	int	ctlr,
 	void	*buff,
@@ -155,45 +155,45 @@
 	unsigned int blkcnt,
 	unsigned int log_unit );
 
-static int ida_open(struct inode *inode, struct file *filep);
-static int ida_release(struct inode *inode, struct file *filep);
-static int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg);
-static int ida_getgeo(struct block_device *bdev, struct hd_geometry *geo);
-static int ida_ctlr_ioctl(ctlr_info_t *h, int dsk, ida_ioctl_t *io);
-
-static void do_ida_request(request_queue_t *q);
-static void start_io(ctlr_info_t *h);
-
-static inline void addQ(cmdlist_t **Qptr, cmdlist_t *c);
-static inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c);
-static inline void complete_buffers(struct bio *bio, int ok);
-static inline void complete_command(cmdlist_t *cmd, int timeout);
-
-static irqreturn_t do_ida_intr(int irq, void *dev_id);
-static void ida_timer(unsigned long tdata);
-static int ida_revalidate(struct gendisk *disk);
-static int revalidate_allvol(ctlr_info_t *host);
-static int cpqarray_register_ctlr(int ctlr, struct pci_dev *pdev);
+int ida_open(struct inode *inode, struct file *filep);
+int ida_release(struct inode *inode, struct file *filep);
+int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg);
+int ida_getgeo(struct block_device *bdev, struct hd_geometry *geo);
+int ida_ctlr_ioctl(ctlr_info_t *h, int dsk, ida_ioctl_t *io);
+
+void do_ida_request(request_queue_t *q);
+void start_io(ctlr_info_t *h);
+
+inline void addQ(cmdlist_t **Qptr, cmdlist_t *c);
+inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c);
+inline void complete_buffers(struct bio *bio, int ok);
+inline void complete_command(cmdlist_t *cmd, int timeout);
+
+irqreturn_t do_ida_intr(int irq, void *dev_id);
+void ida_timer(unsigned long tdata);
+int ida_revalidate(struct gendisk *disk);
+int revalidate_allvol(ctlr_info_t *host);
+int cpqarray_register_ctlr(int ctlr, struct pci_dev *pdev);
 
 #ifdef CONFIG_PROC_FS
-static void ida_procinit(int i);
-static int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data);
+void ida_procinit(int i);
+int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data);
 #else
-static void ida_procinit(int i) {}
+void ida_procinit(int i) {}
 #endif
 
-static inline drv_info_t *get_drv(struct gendisk *disk)
+inline drv_info_t *get_drv(struct gendisk *disk)
 {
 	return disk->private_data;
 }
 
-static inline ctlr_info_t *get_host(struct gendisk *disk)
+inline ctlr_info_t *get_host(struct gendisk *disk)
 {
 	return disk->queue->queuedata;
 }
 
 
-static struct block_device_operations ida_fops  = {
+struct block_device_operations ida_fops  = {
 	.owner		= THIS_MODULE,
 	.open		= ida_open,
 	.release	= ida_release,
@@ -205,13 +205,13 @@
 
 #ifdef CONFIG_PROC_FS
 
-static struct proc_dir_entry *proc_array;
+struct proc_dir_entry *proc_array;
 
 /*
  * Get us a file in /proc/array that says something about each controller.
  * Create /proc/array if it doesn't exist yet.
  */
-static void __init ida_procinit(int i)
+void __init ida_procinit(int i)
 {
 	if (proc_array == NULL) {
 		proc_array = proc_mkdir("cpqarray", proc_root_driver);
@@ -225,7 +225,7 @@
 /*
  * Report information about this controller.
  */
-static int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data)
+int ida_proc_get_info(char *buffer, char **start, off_t offset, int length, int *eof, void *data)
 {
 	off_t pos = 0;
 	off_t len = 0;
@@ -311,7 +311,7 @@
 
 module_param_array(eisa, int, NULL, 0);
 
-static void release_io_mem(ctlr_info_t *c)
+void release_io_mem(ctlr_info_t *c)
 {
 	/* if IO mem was not protected do nothing */
 	if( c->io_mem_addr == 0)
@@ -321,7 +321,7 @@
 	c->io_mem_length = 0;
 }
 
-static void __devexit cpqarray_remove_one(int i)
+void __devexit cpqarray_remove_one(int i)
 {
 	int j;
 	char buff[4];
@@ -353,7 +353,7 @@
 	free_hba(i);
 }
 
-static void __devexit cpqarray_remove_one_pci (struct pci_dev *pdev)
+void __devexit cpqarray_remove_one_pci (struct pci_dev *pdev)
 {
 	int i;
 	ctlr_info_t *tmp_ptr;
@@ -378,7 +378,7 @@
 /* removing an instance that was not removed automatically..
  * must be an eisa card.
  */
-static void __devexit cpqarray_remove_one_eisa (int i)
+void __devexit cpqarray_remove_one_eisa (int i)
 {
 	if (hba[i] == NULL) {
 		printk(KERN_ERR "cpqarray: controller %d appears to have"
@@ -389,7 +389,7 @@
 }
 
 /* pdev is NULL for eisa */
-static int __init cpqarray_register_ctlr( int i, struct pci_dev *pdev)
+int __init cpqarray_register_ctlr( int i, struct pci_dev *pdev)
 {
 	request_queue_t *q;
 	int j;
@@ -510,7 +510,7 @@
 	return -1;
 }
 
-static int __init cpqarray_init_one( struct pci_dev *pdev,
+int __init cpqarray_init_one( struct pci_dev *pdev,
 	const struct pci_device_id *ent)
 {
 	int i;
@@ -538,7 +538,7 @@
 	return (cpqarray_register_ctlr(i, pdev));
 }
 
-static struct pci_driver cpqarray_pci_driver = {
+struct pci_driver cpqarray_pci_driver = {
 	.name = "cpqarray",
 	.probe = cpqarray_init_one,
 	.remove = __devexit_p(cpqarray_remove_one_pci),
@@ -549,7 +549,7 @@
  *  This is it.  Find all the controllers and register them.
  *  returns the number of block devices registered.
  */
-static int __init cpqarray_init(void)
+int __init cpqarray_init(void)
 {
 	int num_cntlrs_reg = 0;
 	int i;
@@ -573,7 +573,7 @@
 
 /* Function to find the first free pointer into our hba[] array */
 /* Returns -1 if no free entries are left.  */
-static int alloc_cpqarray_hba(void)
+int alloc_cpqarray_hba(void)
 {
 	int i;
 
@@ -592,7 +592,7 @@
 	return(-1);
 }
 
-static void free_hba(int i)
+void free_hba(int i)
 {
 	kfree(hba[i]);
 	hba[i]=NULL;
@@ -602,7 +602,7 @@
  * Find the IO address of the controller, its IRQ and so forth.  Fill
  * in some basic stuff into the ctlr_info_t structure.
  */
-static int cpqarray_pci_init(ctlr_info_t *c, struct pci_dev *pdev)
+int cpqarray_pci_init(ctlr_info_t *c, struct pci_dev *pdev)
 {
 	ushort vendor_id, device_id, command;
 	unchar cache_line_size, latency_timer;
@@ -710,7 +710,7 @@
 /*
  * Map (physical) PCI mem into (virtual) kernel space
  */
-static void __iomem *remap_pci_mem(ulong base, ulong size)
+void __iomem *remap_pci_mem(ulong base, ulong size)
 {
         ulong page_base        = ((ulong) base) & PAGE_MASK;
         ulong page_offs        = ((ulong) base) - page_base;
@@ -723,7 +723,7 @@
 /*
  * Config string is a comma separated set of i/o addresses of EISA cards.
  */
-static int cpqarray_setup(char *str)
+int cpqarray_setup(char *str)
 {
 	int i, ints[9];
 
@@ -741,7 +741,7 @@
 /*
  * Find an EISA controller's signature.  Set up an hba if we find it.
  */
-static int __init cpqarray_eisa_detect(void)
+int __init cpqarray_eisa_detect(void)
 {
 	int i=0, j;
 	__u32 board_id;
@@ -819,7 +819,7 @@
 /*
  * Open.  Make sure the device is really there.
  */
-static int ida_open(struct inode *inode, struct file *filep)
+int ida_open(struct inode *inode, struct file *filep)
 {
 	drv_info_t *drv = get_drv(inode->i_bdev->bd_disk);
 	ctlr_info_t *host = get_host(inode->i_bdev->bd_disk);
@@ -844,7 +844,7 @@
 /*
  * Close.  Sync first.
  */
-static int ida_release(struct inode *inode, struct file *filep)
+int ida_release(struct inode *inode, struct file *filep)
 {
 	ctlr_info_t *host = get_host(inode->i_bdev->bd_disk);
 	host->usage_count--;
@@ -854,7 +854,7 @@
 /*
  * Enqueuing and dequeuing functions for cmdlists.
  */
-static inline void addQ(cmdlist_t **Qptr, cmdlist_t *c)
+inline void addQ(cmdlist_t **Qptr, cmdlist_t *c)
 {
 	if (*Qptr == NULL) {
 		*Qptr = c;
@@ -867,7 +867,7 @@
 	}
 }
 
-static inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c)
+inline cmdlist_t *removeQ(cmdlist_t **Qptr, cmdlist_t *c)
 {
 	if (c && c->next != c) {
 		if (*Qptr == c) *Qptr = c->next;
@@ -886,7 +886,7 @@
  * are in here (either via the dummy do_ida_request functions or by being
  * called from the interrupt handler
  */
-static void do_ida_request(request_queue_t *q)
+void do_ida_request(request_queue_t *q)
 {
 	ctlr_info_t *h = q->queuedata;
 	cmdlist_t *c;
@@ -958,7 +958,7 @@
  *
  * Interrupts had better be off if you're in here
  */
-static void start_io(ctlr_info_t *h)
+void start_io(ctlr_info_t *h)
 {
 	cmdlist_t *c;
 
@@ -979,7 +979,7 @@
 	}
 }
 
-static inline void complete_buffers(struct bio *bio, int ok)
+inline void complete_buffers(struct bio *bio, int ok)
 {
 	struct bio *xbh;
 	while(bio) {
@@ -996,7 +996,7 @@
 /*
  * Mark all buffers that cmd was responsible for
  */
-static inline void complete_command(cmdlist_t *cmd, int timeout)
+inline void complete_command(cmdlist_t *cmd, int timeout)
 {
 	struct request *rq = cmd->rq;
 	int ok=1;
@@ -1049,7 +1049,7 @@
  *  Find the command on the completion queue, remove it, tell the OS and
  *  try to queue up more IO
  */
-static irqreturn_t do_ida_intr(int irq, void *dev_id)
+irqreturn_t do_ida_intr(int irq, void *dev_id)
 {
 	ctlr_info_t *h = dev_id;
 	cmdlist_t *c;
@@ -1120,7 +1120,7 @@
  * reset a flags structure so we don't flood the user with
  * "Non-Fatal error" messages.
  */
-static void ida_timer(unsigned long tdata)
+void ida_timer(unsigned long tdata)
 {
 	ctlr_info_t *h = (ctlr_info_t*)tdata;
 
@@ -1129,7 +1129,7 @@
 	h->misc_tflags = 0;
 }
 
-static int ida_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+int ida_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 {
 	drv_info_t *drv = get_drv(bdev->bd_disk);
 
@@ -1150,7 +1150,7 @@
  *  ida_ioctl does some miscellaneous stuff like reporting drive geometry,
  *  setting readahead and submitting commands from userspace to the controller.
  */
-static int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg)
+int ida_ioctl(struct inode *inode, struct file *filep, unsigned int cmd, unsigned long arg)
 {
 	drv_info_t *drv = get_drv(inode->i_bdev->bd_disk);
 	ctlr_info_t *host = get_host(inode->i_bdev->bd_disk);
@@ -1224,7 +1224,7 @@
  * any serious sanity checking on the arguments.  Doing an IDA_WRITE_MEDIA and
  * putting a 64M buffer in the sglist is probably a *bad* idea.
  */
-static int ida_ctlr_ioctl(ctlr_info_t *h, int dsk, ida_ioctl_t *io)
+int ida_ctlr_ioctl(ctlr_info_t *h, int dsk, ida_ioctl_t *io)
 {
 	int ctlr = h->ctlr;
 	cmdlist_t *c;
@@ -1362,7 +1362,7 @@
  * critical (and can wait for kmalloc and possibly sleep) can pass in NULL
  * as the first argument to get a new command.
  */
-static cmdlist_t * cmd_alloc(ctlr_info_t *h, int get_from_pool)
+cmdlist_t * cmd_alloc(ctlr_info_t *h, int get_from_pool)
 {
 	cmdlist_t * c;
 	int i;
@@ -1389,7 +1389,7 @@
 	return c;
 }
 
-static void cmd_free(ctlr_info_t *h, cmdlist_t *c, int got_from_pool)
+void cmd_free(ctlr_info_t *h, cmdlist_t *c, int got_from_pool)
 {
 	int i;
 
@@ -1409,7 +1409,7 @@
     and wait for it to complete.  
     This routine should only be called at init time.
 ***********************************************************************/
-static int sendcmd(
+int sendcmd(
 	__u8	cmd,
 	int	ctlr,
 	void	*buff,
@@ -1520,7 +1520,7 @@
  * particualar logical volume (instead of all of them on a particular
  * controller).
  */
-static int revalidate_allvol(ctlr_info_t *host)
+int revalidate_allvol(ctlr_info_t *host)
 {
 	int ctlr = host->ctlr;
 	int i;
@@ -1574,7 +1574,7 @@
 	return 0;
 }
 
-static int ida_revalidate(struct gendisk *disk)
+int ida_revalidate(struct gendisk *disk)
 {
 	drv_info_t *drv = disk->private_data;
 	set_capacity(disk, drv->nr_blks);
@@ -1587,7 +1587,7 @@
     The memory mapped FIFO is polled for the completion.
     Used only at init time, interrupts disabled.
  ********************************************************************/
-static int pollcomplete(int ctlr)
+int pollcomplete(int ctlr)
 {
 	int done;
 	int i;
@@ -1611,7 +1611,7 @@
     If the PCI mem address registers are written to after this, 
 	 data corruption may occur
 *****************************************************************/
-static void start_fwbk(int ctlr)
+void start_fwbk(int ctlr)
 {
 		id_ctlr_t *id_ctlr_buf; 
 	int ret_code;
@@ -1646,7 +1646,7 @@
     This is a large bit of code which once existed in two flavors,
     It is used only at init time.
 *****************************************************************/
-static void getgeometry(int ctlr)
+void getgeometry(int ctlr)
 {				
 	id_log_drv_t *id_ldrive;
 	id_ctlr_t *id_ctlr_buf;
@@ -1828,7 +1828,7 @@
 
 }
 
-static void __exit cpqarray_exit(void)
+void __exit cpqarray_exit(void)
 {
 	int i;
 
diff -urN -xcprover cproverbm.GKAExt/drivers/block/nbd.c linux-2.6.19-ddverify-seq1/drivers/block/nbd.c
--- cproverbm.GKAExt/drivers/block/nbd.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/block/nbd.c	2011-01-12 13:39:08.000000000 +0000
@@ -399,7 +399,7 @@
  *   { printk( "Warning: Ignoring result!\n"); nbd_end_request( req ); }
  */
 
-static void do_nbd_request(request_queue_t * q)
+void do_nbd_request(request_queue_t * q)
 {
 	struct request *req;
 	
diff -urN -xcprover cproverbm.GKAExt/drivers/block/umem.c linux-2.6.19-ddverify-seq1/drivers/block/umem.c
--- cproverbm.GKAExt/drivers/block/umem.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/block/umem.c	2011-01-12 13:39:08.000000000 +0000
@@ -73,7 +73,7 @@
 #define DRIVER_AUTHOR "San Mehat, Johannes Erdfelt, NeilBrown"
 #define DRIVER_DESC "Micro Memory(tm) PCI memory board block driver"
 
-static int debug;
+int debug;
 /* #define HW_TRACE(x)     writeb(x,cards[0].csr_remap + MEMCTRLSTATUS_MAGIC) */
 #define HW_TRACE(x)
 
@@ -83,17 +83,17 @@
 module_param(debug, int, 0644);
 MODULE_PARM_DESC(debug, "Debug bitmask");
 
-static int pci_read_cmd = 0x0C;		/* Read Multiple */
+int pci_read_cmd = 0x0C;		/* Read Multiple */
 module_param(pci_read_cmd, int, 0);
 MODULE_PARM_DESC(pci_read_cmd, "PCI read command");
 
-static int pci_write_cmd = 0x0F;	/* Write and Invalidate */
+int pci_write_cmd = 0x0F;	/* Write and Invalidate */
 module_param(pci_write_cmd, int, 0);
 MODULE_PARM_DESC(pci_write_cmd, "PCI write command");
 
-static int pci_cmds;
+int pci_cmds;
 
-static int major_nr;
+int major_nr;
 
 #include <linux/blkdev.h>
 #include <linux/blkpg.h>
@@ -149,22 +149,22 @@
 	int		flags;
 };
 
-static struct cardinfo cards[MM_MAXCARDS];
-static struct block_device_operations mm_fops;
-static struct timer_list battery_timer;
+struct cardinfo cards[MM_MAXCARDS];
+struct block_device_operations mm_fops;
+struct timer_list battery_timer;
 
-static int num_cards = 0;
+int num_cards = 0;
 
-static struct gendisk *mm_gendisk[MM_MAXCARDS];
+struct gendisk *mm_gendisk[MM_MAXCARDS];
 
-static void check_batteries(struct cardinfo *card);
+void check_batteries(struct cardinfo *card);
 
 /*
 -----------------------------------------------------------------------------------
 --                           get_userbit
 -----------------------------------------------------------------------------------
 */
-static int get_userbit(struct cardinfo *card, int bit)
+int get_userbit(struct cardinfo *card, int bit)
 {
 	unsigned char led;
 
@@ -176,7 +176,7 @@
 --                            set_userbit
 -----------------------------------------------------------------------------------
 */
-static int set_userbit(struct cardinfo *card, int bit, unsigned char state)
+int set_userbit(struct cardinfo *card, int bit, unsigned char state)
 {
 	unsigned char led;
 
@@ -197,7 +197,7 @@
 /*
  * NOTE: For the power LED, use the LED_POWER_* macros since they differ
  */
-static void set_led(struct cardinfo *card, int shift, unsigned char state)
+void set_led(struct cardinfo *card, int shift, unsigned char state)
 {
 	unsigned char led;
 
@@ -218,7 +218,7 @@
 --                              dump_regs
 -----------------------------------------------------------------------------------
 */
-static void dump_regs(struct cardinfo *card)
+void dump_regs(struct cardinfo *card)
 {
 	unsigned char *p;
 	int i, i1;
@@ -239,7 +239,7 @@
 --                            dump_dmastat
 -----------------------------------------------------------------------------------
 */
-static void dump_dmastat(struct cardinfo *card, unsigned int dmastat)
+void dump_dmastat(struct cardinfo *card, unsigned int dmastat)
 {
 	printk(KERN_DEBUG "MM%d*: DMAstat - ", card->card_number);
 	if (dmastat & DMASCR_ANY_ERR)
@@ -284,7 +284,7 @@
  * The processing of the result is done in a tasklet.
  */
 
-static void mm_start_io(struct cardinfo *card)
+void mm_start_io(struct cardinfo *card)
 {
 	/* we have the lock, we know there is
 	 * no IO active, and we know that card->Active
@@ -333,9 +333,9 @@
 	       card->csr_remap + DMA_STATUS_CTRL);
 }
 
-static int add_bio(struct cardinfo *card);
+int add_bio(struct cardinfo *card);
 
-static void activate(struct cardinfo *card)
+void activate(struct cardinfo *card)
 {
 	/* if No page is Active, and Ready is 
 	 * not empty, then switch Ready page
@@ -357,7 +357,7 @@
 	} while (card->Active == -1 && add_bio(card));
 }
 
-static inline void reset_page(struct mm_page *page)
+inline void reset_page(struct mm_page *page)
 {
 	page->cnt = 0;
 	page->headcnt = 0;
@@ -365,7 +365,7 @@
 	page->biotail = & page->bio;
 }
 
-static void mm_unplug_device(request_queue_t *q)
+void mm_unplug_device(request_queue_t *q)
 {
 	struct cardinfo *card = q->queuedata;
 	unsigned long flags;
@@ -381,7 +381,7 @@
  * one bh off list and add it.
  * return 1 if there was room, else 0.
  */
-static int add_bio(struct cardinfo *card)
+int add_bio(struct cardinfo *card)
 {
 	struct mm_page *p;
 	struct mm_dma_desc *desc;
@@ -452,7 +452,7 @@
 	return 1;
 }
 
-static void process_page(unsigned long data)
+void process_page(unsigned long data)
 {
 	/* check if any of the requests in the page are DMA_COMPLETE,
 	 * and deal with them appropriately.
@@ -549,7 +549,7 @@
 --                              mm_make_request
 -----------------------------------------------------------------------------------
 */
-static int mm_make_request(request_queue_t *q, struct bio *bio)
+int mm_make_request(request_queue_t *q, struct bio *bio)
 {
 	struct cardinfo *card = q->queuedata;
 	pr_debug("mm_make_request %llu %u\n",
@@ -571,7 +571,7 @@
 --                              mm_interrupt
 -----------------------------------------------------------------------------------
 */
-static irqreturn_t mm_interrupt(int irq, void *__card)
+irqreturn_t mm_interrupt(int irq, void *__card)
 {
 	struct cardinfo *card = (struct cardinfo *) __card;
 	unsigned int dma_status;
@@ -677,7 +677,7 @@
  * If both batteries are bad, flash the LED quickly
  * If either battery is bad, flash the LED semi quickly
  */
-static void set_fault_to_battery_status(struct cardinfo *card)
+void set_fault_to_battery_status(struct cardinfo *card)
 {
 	if (card->battery[0].good && card->battery[1].good)
 		set_led(card, LED_FAULT, LED_OFF);
@@ -689,7 +689,7 @@
 		set_led(card, LED_FAULT, LED_FLASH_3_5);
 }
 
-static void init_battery_timer(void);
+void init_battery_timer(void);
 
 
 /*
@@ -697,7 +697,7 @@
 --                            check_battery
 -----------------------------------------------------------------------------------
 */
-static int check_battery(struct cardinfo *card, int battery, int status)
+int check_battery(struct cardinfo *card, int battery, int status)
 {
 	if (status != card->battery[battery].good) {
 		card->battery[battery].good = !card->battery[battery].good;
@@ -730,7 +730,7 @@
 --                              check_batteries
 -----------------------------------------------------------------------------------
 */
-static void check_batteries(struct cardinfo *card)
+void check_batteries(struct cardinfo *card)
 {
 	/* NOTE: this must *never* be called while the card
 	 * is doing (bus-to-card) DMA, or you will need the
@@ -753,7 +753,7 @@
 		set_fault_to_battery_status(card);
 }
 
-static void check_all_batteries(unsigned long ptr)
+void check_all_batteries(unsigned long ptr)
 {
 	int i;
 
@@ -775,7 +775,7 @@
 --                            init_battery_timer
 -----------------------------------------------------------------------------------
 */
-static void init_battery_timer(void)
+void init_battery_timer(void)
 {
 	init_timer(&battery_timer);
 	battery_timer.function = check_all_batteries;
@@ -787,7 +787,7 @@
 --                              del_battery_timer
 -----------------------------------------------------------------------------------
 */
-static void del_battery_timer(void)
+void del_battery_timer(void)
 {
 	del_timer(&battery_timer);
 }
@@ -804,14 +804,14 @@
  *	That's crap, since doing that while some partitions are opened
  * or mounted will give you really nasty results.
  */
-static int mm_revalidate(struct gendisk *disk)
+int mm_revalidate(struct gendisk *disk)
 {
 	struct cardinfo *card = disk->private_data;
 	set_capacity(disk, card->mm_size << 1);
 	return 0;
 }
 
-static int mm_getgeo(struct block_device *bdev, struct hd_geometry *geo)
+int mm_getgeo(struct block_device *bdev, struct hd_geometry *geo)
 {
 	struct cardinfo *card = bdev->bd_disk->private_data;
 	int size = card->mm_size * (1024 / MM_HARDSECT);
@@ -833,7 +833,7 @@
 -----------------------------------------------------------------------------------
   Future support for removable devices
 */
-static int mm_check_change(struct gendisk *disk)
+int mm_check_change(struct gendisk *disk)
 {
 /*  struct cardinfo *dev = disk->private_data; */
 	return 0;
@@ -843,7 +843,7 @@
 --                             mm_fops
 -----------------------------------------------------------------------------------
 */
-static struct block_device_operations mm_fops = {
+struct block_device_operations mm_fops = {
 	.owner		= THIS_MODULE,
 	.getgeo		= mm_getgeo,
 	.revalidate_disk= mm_revalidate,
@@ -854,7 +854,7 @@
 --                                mm_pci_probe
 -----------------------------------------------------------------------------------
 */
-static int __devinit mm_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
+int __devinit mm_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	int ret = -ENODEV;
 	struct cardinfo *card = &cards[num_cards];
@@ -1111,7 +1111,7 @@
 --                              mm_pci_remove
 -----------------------------------------------------------------------------------
 */
-static void mm_pci_remove(struct pci_dev *dev)
+void mm_pci_remove(struct pci_dev *dev)
 {
 	struct cardinfo *card = pci_get_drvdata(dev);
 
@@ -1135,7 +1135,7 @@
 	blk_cleanup_queue(card->queue);
 }
 
-static const struct pci_device_id mm_pci_ids[] = { {
+const struct pci_device_id mm_pci_ids[] = { {
 	.vendor =	PCI_VENDOR_ID_MICRO_MEMORY,
 	.device =	PCI_DEVICE_ID_MICRO_MEMORY_5415CN,
 	}, {
@@ -1156,7 +1156,7 @@
 
 MODULE_DEVICE_TABLE(pci, mm_pci_ids);
 
-static struct pci_driver mm_pci_driver = {
+struct pci_driver mm_pci_driver = {
 	.name =		"umem",
 	.id_table =	mm_pci_ids,
 	.probe =	mm_pci_probe,
@@ -1168,7 +1168,7 @@
 -----------------------------------------------------------------------------------
 */
 
-static int __init mm_init(void)
+int __init mm_init(void)
 {
 	int retval, i;
 	int err;
@@ -1218,7 +1218,7 @@
 --                             mm_cleanup
 -----------------------------------------------------------------------------------
 */
-static void __exit mm_cleanup(void)
+void __exit mm_cleanup(void)
 {
 	int i;
 
diff -urN -xcprover cproverbm.GKAExt/drivers/cdrom/aztcd.c linux-2.6.19-ddverify-seq1/drivers/cdrom/aztcd.c
--- cproverbm.GKAExt/drivers/cdrom/aztcd.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/cdrom/aztcd.c	2011-01-12 13:39:08.000000000 +0000
@@ -225,9 +225,9 @@
 #define AZT_DEBUG_MULTISESSION
 #endif
 
-static struct request_queue *azt_queue;
+struct request_queue *azt_queue;
 
-static int current_valid(void)
+int current_valid(void)
 {
         return CURRENT &&
 		CURRENT->cmd == READ &&
@@ -262,79 +262,79 @@
   Global Variables
   ##########################################################################
 */
-static int aztPresent = 0;
+int aztPresent = 0;
 
-static volatile int azt_transfer_is_active = 0;
+volatile int azt_transfer_is_active = 0;
 
-static char azt_buf[CD_FRAMESIZE_RAW * AZT_BUF_SIZ];	/*buffer for block size conversion */
+char azt_buf[CD_FRAMESIZE_RAW * AZT_BUF_SIZ];	/*buffer for block size conversion */
 #if AZT_PRIVATE_IOCTLS
-static char buf[CD_FRAMESIZE_RAW];	/*separate buffer for the ioctls */
+char buf[CD_FRAMESIZE_RAW];	/*separate buffer for the ioctls */
 #endif
 
-static volatile int azt_buf_bn[AZT_BUF_SIZ], azt_next_bn;
-static volatile int azt_buf_in, azt_buf_out = -1;
-static volatile int azt_error = 0;
-static int azt_open_count = 0;
-static volatile enum azt_state_e azt_state = AZT_S_IDLE;
+volatile int azt_buf_bn[AZT_BUF_SIZ], azt_next_bn;
+volatile int azt_buf_in, azt_buf_out = -1;
+volatile int azt_error = 0;
+int azt_open_count = 0;
+volatile enum azt_state_e azt_state = AZT_S_IDLE;
 #ifdef AZT_TEST3
-static volatile enum azt_state_e azt_state_old = AZT_S_STOP;
-static volatile int azt_st_old = 0;
+volatile enum azt_state_e azt_state_old = AZT_S_STOP;
+volatile int azt_st_old = 0;
 #endif
-static volatile enum azt_read_modes azt_read_mode = AZT_MODE_1;
+volatile enum azt_read_modes azt_read_mode = AZT_MODE_1;
 
-static int azt_mode = -1;
-static volatile int azt_read_count = 1;
+int azt_mode = -1;
+volatile int azt_read_count = 1;
 
-static int azt_port = AZT_BASE_ADDR;
+int azt_port = AZT_BASE_ADDR;
 
 module_param(azt_port, int, 0);
 
-static int azt_port_auto[16] = AZT_BASE_AUTO;
+int azt_port_auto[16] = AZT_BASE_AUTO;
 
-static char azt_cont = 0;
-static char azt_init_end = 0;
-static char azt_auto_eject = AZT_AUTO_EJECT;
+char azt_cont = 0;
+char azt_init_end = 0;
+char azt_auto_eject = AZT_AUTO_EJECT;
 
-static int AztTimeout, AztTries;
-static DECLARE_WAIT_QUEUE_HEAD(azt_waitq);
-static DEFINE_TIMER(delay_timer, NULL, 0, 0);
+int AztTimeout, AztTries;
+DECLARE_WAIT_QUEUE_HEAD(azt_waitq);
+DEFINE_TIMER(delay_timer, NULL, 0, 0);
 
-static struct azt_DiskInfo DiskInfo;
-static struct azt_Toc Toc[MAX_TRACKS];
-static struct azt_Play_msf azt_Play;
+struct azt_DiskInfo DiskInfo;
+struct azt_Toc Toc[MAX_TRACKS];
+struct azt_Play_msf azt_Play;
 
-static int aztAudioStatus = CDROM_AUDIO_NO_STATUS;
-static char aztDiskChanged = 1;
-static char aztTocUpToDate = 0;
+int aztAudioStatus = CDROM_AUDIO_NO_STATUS;
+char aztDiskChanged = 1;
+char aztTocUpToDate = 0;
 
-static unsigned char aztIndatum;
-static unsigned long aztTimeOutCount;
-static int aztCmd = 0;
+unsigned char aztIndatum;
+unsigned long aztTimeOutCount;
+int aztCmd = 0;
 
-static DEFINE_SPINLOCK(aztSpin);
+DEFINE_SPINLOCK(aztSpin);
 
 /*###########################################################################
    Function Prototypes
   ###########################################################################
 */
 /* CDROM Drive Low Level I/O Functions */
-static void aztStatTimer(void);
+void aztStatTimer(void);
 
 /* CDROM Drive Command Functions */
-static int aztGetDiskInfo(void);
+int aztGetDiskInfo(void);
 #if AZT_MULTISESSION
-static int aztGetMultiDiskInfo(void);
+int aztGetMultiDiskInfo(void);
 #endif
-static int aztGetToc(int multi);
+int aztGetToc(int multi);
 
 /* Kernel Interface Functions */
-static int check_aztcd_media_change(struct gendisk *disk);
-static int aztcd_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
+int check_aztcd_media_change(struct gendisk *disk);
+int aztcd_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
 		       unsigned long arg);
-static int aztcd_open(struct inode *ip, struct file *fp);
-static int aztcd_release(struct inode *inode, struct file *file);
+int aztcd_open(struct inode *ip, struct file *fp);
+int aztcd_release(struct inode *inode, struct file *file);
 
-static struct block_device_operations azt_fops = {
+struct block_device_operations azt_fops = {
 	.owner		= THIS_MODULE,
 	.open		= aztcd_open,
 	.release	= aztcd_release,
@@ -343,13 +343,13 @@
 };
 
 /* Aztcd State Machine: Controls Drive Operating State */
-static void azt_poll(void);
+void azt_poll(void);
 
 /* Miscellaneous support functions */
-static void azt_hsg2msf(long hsg, struct msf *msf);
-static long azt_msf2hsg(struct msf *mp);
-static void azt_bin2bcd(unsigned char *p);
-static int azt_bcd2bin(unsigned char bcd);
+void azt_hsg2msf(long hsg, struct msf *msf);
+long azt_msf2hsg(struct msf *mp);
+void azt_bin2bcd(unsigned char *p);
+int azt_bcd2bin(unsigned char bcd);
 
 /*##########################################################################
   CDROM Drive Low Level I/O Functions
@@ -359,7 +359,7 @@
    busy waiting */
 /* Wait for OP_OK = drive answers with AFL_OP_OK after receiving a command*/
 # define OP_OK op_ok()
-static void op_ok(void)
+void op_ok(void)
 {
 	aztTimeOutCount = 0;
 	do {
@@ -375,7 +375,7 @@
 /* Wait for PA_OK = drive answers with AFL_PA_OK after receiving parameters*/
 #if 0
 # define PA_OK pa_ok()
-static void pa_ok(void)
+void pa_ok(void)
 {
 	aztTimeOutCount = 0;
 	do {
@@ -391,7 +391,7 @@
 
 /* Wait for STEN=Low = handshake signal 'AFL_.._OK available or command executed*/
 # define STEN_LOW  sten_low()
-static void sten_low(void)
+void sten_low(void)
 {
 	aztTimeOutCount = 0;
 	do {
@@ -409,7 +409,7 @@
 
 /* Wait for DTEN=Low = handshake signal 'Data available'*/
 # define DTEN_LOW dten_low()
-static void dten_low(void)
+void dten_low(void)
 {
 	aztTimeOutCount = 0;
 	do {
@@ -427,7 +427,7 @@
  * may cause kernel panic when used in the wrong place
 */
 #define STEN_LOW_WAIT   statusAzt()
-static void statusAzt(void)
+void statusAzt(void)
 {
 	AztTimeout = AZT_STATUS_DELAY;
 	SET_TIMER(aztStatTimer, HZ / 100);
@@ -438,7 +438,7 @@
 	return;
 }
 
-static void aztStatTimer(void)
+void aztStatTimer(void)
 {
 	if (!(inb(STATUS_PORT) & AFL_STATUS)) {
 		wake_up(&azt_waitq);
@@ -460,7 +460,7 @@
 /* 
  * Send a single command, return -1 on error, else 0
 */
-static int aztSendCmd(int cmd)
+int aztSendCmd(int cmd)
 {
 	unsigned char data;
 	int retry;
@@ -509,7 +509,7 @@
 /*
  * Send a play or read command to the drive, return -1 on error, else 0
 */
-static int sendAztCmd(int cmd, struct azt_Play_msf *params)
+int sendAztCmd(int cmd, struct azt_Play_msf *params)
 {
 	unsigned char data;
 	int retry;
@@ -550,7 +550,7 @@
 /*
  * Send a seek command to the drive, return -1 on error, else 0
 */
-static int aztSeek(struct azt_Play_msf *params)
+int aztSeek(struct azt_Play_msf *params)
 {
 	unsigned char data;
 	int retry;
@@ -586,7 +586,7 @@
    does not seem to work with Aztech drives, behavior is completely indepen-
    dent on which mode is set ???
 */
-static int aztSetDiskType(int type)
+int aztSetDiskType(int type)
 {
 	unsigned char data;
 	int retry;
@@ -622,7 +622,7 @@
 /* used in azt_poll to poll the status, expects another program to issue a 
  * ACMD_GET_STATUS directly before 
  */
-static int aztStatus(void)
+int aztStatus(void)
 {
 	int st;
 /*	int i;
@@ -640,7 +640,7 @@
 /*
  * Get the drive status
  */
-static int getAztStatus(void)
+int getAztStatus(void)
 {
 	int st;
 
@@ -674,7 +674,7 @@
 /*
  * Send a 'Play' command and get the status.  Use only from the top half.
  */
-static int aztPlay(struct azt_Play_msf *arg)
+int aztPlay(struct azt_Play_msf *arg)
 {
 	if (sendAztCmd(ACMD_PLAY_AUDIO, arg) < 0)
 		RETURNM("aztPlay", -1);
@@ -686,14 +686,14 @@
  * lock it closed when the cd is mounted.  Leave the tray
  * locking as an option
  */
-static void aztCloseDoor(void)
+void aztCloseDoor(void)
 {
 	aztSendCmd(ACMD_CLOSE);
 	STEN_LOW;
 	return;
 }
 
-static void aztLockDoor(void)
+void aztLockDoor(void)
 {
 #if AZT_ALLOW_TRAY_LOCK
 	aztSendCmd(ACMD_LOCK);
@@ -702,7 +702,7 @@
 	return;
 }
 
-static void aztUnlockDoor(void)
+void aztUnlockDoor(void)
 {
 #if AZT_ALLOW_TRAY_LOCK
 	aztSendCmd(ACMD_UNLOCK);
@@ -716,7 +716,7 @@
  * is used to avoid excessive rescheduling. The read command itself must
  * be issued with aztSendCmd() directly before
  */
-static int aztGetValue(unsigned char *result)
+int aztGetValue(unsigned char *result)
 {
 	int s;
 
@@ -734,7 +734,7 @@
  * Read the current Q-channel info.  Also used for reading the
  * table of contents.
  */
-static int aztGetQChannelInfo(struct azt_Toc *qp)
+int aztGetQChannelInfo(struct azt_Toc *qp)
 {
 	unsigned char notUsed;
 	int st;
@@ -791,7 +791,7 @@
 /*
  * Read the table of contents (TOC) and TOC header if necessary
  */
-static int aztUpdateToc(void)
+int aztUpdateToc(void)
 {
 	int st;
 
@@ -872,7 +872,7 @@
 /* Read the table of contents header, i.e. no. of tracks and start of first 
  * track
  */
-static int aztGetDiskInfo(void)
+int aztGetDiskInfo(void)
 {
 	int limit;
 	unsigned char test;
@@ -931,7 +931,7 @@
 /*
  * Get Multisession Disk Info
  */
-static int aztGetMultiDiskInfo(void)
+int aztGetMultiDiskInfo(void)
 {
 	int limit, k = 5;
 	unsigned char test;
@@ -1037,7 +1037,7 @@
 /*
  * Read the table of contents (TOC)
  */
-static int aztGetToc(int multi)
+int aztGetToc(int multi)
 {
 	int i, px;
 	int limit;
@@ -1122,7 +1122,7 @@
 */
 
 #ifndef MODULE
-static int __init aztcd_setup(char *str)
+int __init aztcd_setup(char *str)
 {
 	int ints[4];
 
@@ -1142,7 +1142,7 @@
 /* 
  * Checking if the media has been changed
 */
-static int check_aztcd_media_change(struct gendisk *disk)
+int check_aztcd_media_change(struct gendisk *disk)
 {
 	if (aztDiskChanged) {	/* disk changed */
 		aztDiskChanged = 0;
@@ -1154,7 +1154,7 @@
 /*
  * Kernel IO-controls
 */
-static int aztcd_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
+int aztcd_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
 		       unsigned long arg)
 {
 	int i;
@@ -1522,7 +1522,7 @@
  * Take care of the different block sizes between cdrom and Linux.
  * When Linux gets variable block sizes this will probably go away.
  */
-static void azt_transfer(void)
+void azt_transfer(void)
 {
 #ifdef AZT_TEST
 	printk("aztcd: executing azt_transfer Time:%li\n", jiffies);
@@ -1558,7 +1558,7 @@
 	}
 }
 
-static void do_aztcd_request(request_queue_t * q)
+void do_aztcd_request(request_queue_t * q)
 {
 #ifdef AZT_TEST
 	printk(" do_aztcd_request(%ld+%ld) Time:%li\n", CURRENT->sector,
@@ -1601,7 +1601,7 @@
 }
 
 
-static void azt_invalidate_buffers(void)
+void azt_invalidate_buffers(void)
 {
 	int i;
 
@@ -1616,7 +1616,7 @@
 /*
  * Open the device special file.  Check that a disk is in.
  */
-static int aztcd_open(struct inode *ip, struct file *fp)
+int aztcd_open(struct inode *ip, struct file *fp)
 {
 	int st;
 
@@ -1665,7 +1665,7 @@
 /*
  * On close, we flush all azt blocks from the buffer cache.
  */
-static int aztcd_release(struct inode *inode, struct file *file)
+int aztcd_release(struct inode *inode, struct file *file)
 {
 #ifdef AZT_DEBUG
 	printk("aztcd: executing aztcd_release\n");
@@ -1682,13 +1682,13 @@
 	return 0;
 }
 
-static struct gendisk *azt_disk;
+struct gendisk *azt_disk;
 
 /*
  * Test for presence of drive and initialize it.  Called at boot time.
  */
 
-static int __init aztcd_init(void)
+int __init aztcd_init(void)
 {
 	long int count, max_count;
 	unsigned char result[50];
@@ -1938,7 +1939,7 @@
 
 }
 
-static void __exit aztcd_exit(void)
+void __exit aztcd_exit(void)
 {
 	del_gendisk(azt_disk);
 	put_disk(azt_disk);
@@ -1962,7 +1963,7 @@
   Aztcd State Machine: Controls Drive Operating State
   ##########################################################################
 */
-static void azt_poll(void)
+void azt_poll(void)
 {
 	int st = 0;
 	int loop_ctl = 1;
@@ -2449,7 +2450,7 @@
  * Miscellaneous support functions
   ###########################################################################
 */
-static void azt_hsg2msf(long hsg, struct msf *msf)
+void azt_hsg2msf(long hsg, struct msf *msf)
 {
 	hsg += 150;
 	msf->min = hsg / 4500;
@@ -2469,13 +2470,13 @@
 	azt_bin2bcd(&msf->frame);
 }
 
-static long azt_msf2hsg(struct msf *mp)
+long azt_msf2hsg(struct msf *mp)
 {
 	return azt_bcd2bin(mp->frame) + azt_bcd2bin(mp->sec) * 75
 	    + azt_bcd2bin(mp->min) * 4500 - CD_MSF_OFFSET;
 }
 
-static void azt_bin2bcd(unsigned char *p)
+void azt_bin2bcd(unsigned char *p)
 {
 	int u, t;
 
@@ -2484,7 +2485,7 @@
 	*p = u | (t << 4);
 }
 
-static int azt_bcd2bin(unsigned char bcd)
+int azt_bcd2bin(unsigned char bcd)
 {
 	return (bcd >> 4) * 10 + (bcd & 0xF);
 }
diff -urN -xcprover cproverbm.GKAExt/drivers/cdrom/cdu31a.c linux-2.6.19-ddverify-seq1/drivers/cdrom/cdu31a.c
--- cproverbm.GKAExt/drivers/cdrom/cdu31a.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/cdrom/cdu31a.c	2011-01-12 13:39:08.000000000 +0000
@@ -513,7 +513,7 @@
 	outb(cmd, sony_cd_cmd_reg);
 }
 
-static irqreturn_t cdu31a_interrupt(int irq, void *dev_id)
+static irqreturn_t cdu31a_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	unsigned char val;
 
@@ -2669,7 +2667,7 @@
 	return retval;
 }
 
-static int scd_read_audio(struct cdrom_device_info *cdi,
+static int scd_dev_ioctl(struct cdrom_device_info *cdi,
 			 unsigned int cmd, unsigned long arg)
 {
 	void __user *argp = (void __user *)arg;
diff -urN -xcprover cproverbm.GKAExt/drivers/char/applicom.c linux-2.6.19-ddverify-seq1/drivers/char/applicom.c
--- cproverbm.GKAExt/drivers/char/applicom.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/applicom.c	2011-01-12 13:39:08.000000000 +0000
@@ -59,13 +59,13 @@
 #endif
 #define MAX_PCI_DEVICE_NUM 3
 
-static char *applicom_pci_devnames[] = {
+char *applicom_pci_devnames[] = {
 	"PCI board",
 	"PCI2000IBS / PCI2000CAN",
 	"PCI2000PFB"
 };
 
-static struct pci_device_id applicom_pci_tbl[] = {
+struct pci_device_id applicom_pci_tbl[] = {
 	{ PCI_VENDOR_ID_APPLICOM, PCI_DEVICE_ID_APPLICOM_PCIGENERIC,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
 	{ PCI_VENDOR_ID_APPLICOM, PCI_DEVICE_ID_APPLICOM_PCI2000IBS_CAN,
@@ -83,7 +83,7 @@
 MODULE_SUPPORTED_DEVICE("ac");
 
 
-static struct applicom_board {
+struct applicom_board {
 	unsigned long PhysIO;
 	void __iomem *RamIO;
 	wait_queue_head_t FlagSleepSend;
@@ -91,28 +91,28 @@
 	spinlock_t mutex;
 } apbs[MAX_BOARD];
 
-static unsigned int irq = 0;	/* interrupt number IRQ       */
-static unsigned long mem = 0;	/* physical segment of board  */
+unsigned int irq = 0;	/* interrupt number IRQ       */
+unsigned long mem = 0;	/* physical segment of board  */
 
 module_param(irq, uint, 0);
 MODULE_PARM_DESC(irq, "IRQ of the Applicom board");
 module_param(mem, ulong, 0);
 MODULE_PARM_DESC(mem, "Shared Memory Address of Applicom board");
 
-static unsigned int numboards;	/* number of installed boards */
-static volatile unsigned char Dummy;
-static DECLARE_WAIT_QUEUE_HEAD(FlagSleepRec);
-static unsigned int WriteErrorCount;	/* number of write error      */
-static unsigned int ReadErrorCount;	/* number of read error       */
-static unsigned int DeviceErrorCount;	/* number of device error     */
-
-static ssize_t ac_read (struct file *, char __user *, size_t, loff_t *);
-static ssize_t ac_write (struct file *, const char __user *, size_t, loff_t *);
-static int ac_ioctl(struct inode *, struct file *, unsigned int,
+unsigned int numboards;	/* number of installed boards */
+volatile unsigned char Dummy;
+DECLARE_WAIT_QUEUE_HEAD(FlagSleepRec);
+unsigned int WriteErrorCount;	/* number of write error      */
+unsigned int ReadErrorCount;	/* number of read error       */
+unsigned int DeviceErrorCount;	/* number of device error     */
+
+ssize_t ac_read (struct file *, char __user *, size_t, loff_t *);
+ssize_t ac_write (struct file *, const char __user *, size_t, loff_t *);
+int ac_ioctl(struct inode *, struct file *, unsigned int,
 		    unsigned long);
-static irqreturn_t ac_interrupt(int, void *);
+irqreturn_t ac_interrupt(int, void *);
 
-static const struct file_operations ac_fops = {
+const struct file_operations ac_fops = {
 	.owner = THIS_MODULE,
 	.llseek = no_llseek,
 	.read = ac_read,
@@ -120,15 +120,15 @@
 	.ioctl = ac_ioctl,
 };
 
-static struct miscdevice ac_miscdev = {
+struct miscdevice ac_miscdev = {
 	AC_MINOR,
 	"ac",
 	&ac_fops
 };
 
-static int dummy;	/* dev_id for request_irq() */
+int dummy;	/* dev_id for request_irq() */
 
-static int ac_register_board(unsigned long physloc, void __iomem *loc, 
+int ac_register_board(unsigned long physloc, void __iomem *loc, 
 		      unsigned char boardno)
 {
 	volatile unsigned char byte_reset_it;
@@ -166,7 +166,7 @@
 	return boardno + 1;
 }
 
-static void __exit applicom_exit(void)
+void __exit applicom_exit(void)
 {
 	unsigned int i;
 
@@ -184,7 +184,7 @@
 	}
 }
 
-static int __init applicom_init(void)
+int __init applicom_init(void)
 {
 	int i, numisa = 0;
 	struct pci_dev *dev = NULL;
@@ -356,7 +357,7 @@
 module_exit(applicom_exit);
 
 
-static ssize_t ac_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
+ssize_t ac_write(struct file *file, const char __user *buf, size_t count, loff_t * ppos)
 {
 	unsigned int NumCard;	/* Board number 1 -> 8           */
 	unsigned int IndexCard;	/* Index board number 0 -> 7     */
@@ -480,7 +481,7 @@
 	return 0;
 }
 
-static int do_ac_read(int IndexCard, char __user *buf,
+int do_ac_read(int IndexCard, char __user *buf,
 		struct st_ram_io *st_loc, struct mailbox *mailbox)
 {
 	void __iomem *from = apbs[IndexCard].RamIO + RAM_TO_PC;
@@ -534,7 +535,7 @@
 	return (sizeof(struct st_ram_io) + sizeof(struct mailbox));
 }
 
-static ssize_t ac_read (struct file *filp, char __user *buf, size_t count, loff_t *ptr)
+ssize_t ac_read (struct file *filp, char __user *buf, size_t count, loff_t *ptr)
 {
 	unsigned long flags;
 	unsigned int i;
@@ -617,7 +618,7 @@
 	} 
 }
 
-static irqreturn_t ac_interrupt(int vec, void *dev_instance)
+irqreturn_t ac_interrupt(int vec, void *dev_instance)
 {
 	unsigned int i;
 	unsigned int FlagInt;
@@ -693,7 +694,7 @@
 
 
 
-static int ac_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+int ac_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
      
 {				/* @ ADG ou ATO selon le cas */
 	int i;
diff -urN -xcprover cproverbm.GKAExt/drivers/char/cs5535_gpio.c linux-2.6.19-ddverify-seq1/drivers/char/cs5535_gpio.c
--- cproverbm.GKAExt/drivers/char/cs5535_gpio.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/cs5535_gpio.c	2011-01-12 13:39:08.000000000 +0000
@@ -27,25 +27,25 @@
 MODULE_DESCRIPTION("AMD CS5535/CS5536 GPIO Pin Driver");
 MODULE_LICENSE("GPL");
 
-static int major;
+int major;
 module_param(major, int, 0);
 MODULE_PARM_DESC(major, "Major device number");
 
-static ulong mask;
+ulong mask;
 module_param(mask, ulong, 0);
 MODULE_PARM_DESC(mask, "GPIO channel mask");
 
 #define MSR_LBAR_GPIO		0x5140000C
 
-static u32 gpio_base;
+u32 gpio_base;
 
-static struct pci_device_id divil_pci[] = {
+struct pci_device_id divil_pci[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_NS,  PCI_DEVICE_ID_NS_CS5535_ISA) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_CS5536_ISA) },
 	{ } /* NULL entry */
 };
 
-static struct cdev cs5535_gpio_cdev;
+struct cdev cs5535_gpio_cdev;
 
 /* reserve 32 entries even though some aren't usable */
 #define CS5535_GPIO_COUNT	32
@@ -59,7 +59,7 @@
 	char	on;
 	char	off;
 };
-static struct gpio_regmap rm[] =
+struct gpio_regmap rm[] =
 {
 	{ 0x30, 0x00, '1', '0' },	/* GPIOx_READ_BACK / GPIOx_OUT_VAL */
 	{ 0x20, 0x20, 'I', 'i' },	/* GPIOx_IN_EN */
@@ -74,12 +74,12 @@
  * Gets the register offset for the GPIO bank.
  * Low (0-15) starts at 0x00, high (16-31) starts at 0x80
  */
-static inline u32 cs5535_lowhigh_base(int reg)
+inline u32 cs5535_lowhigh_base(int reg)
 {
 	return (reg & 0x10) << 3;
 }
 
-static ssize_t cs5535_gpio_write(struct file *file, const char __user *data,
+ssize_t cs5535_gpio_write(struct file *file, const char __user *data,
 				 size_t len, loff_t *ppos)
 {
 	u32	m = iminor(file->f_dentry->d_inode);
@@ -114,7 +114,7 @@
 	return len;
 }
 
-static ssize_t cs5535_gpio_read(struct file *file, char __user *buf,
+ssize_t cs5535_gpio_read(struct file *file, char __user *buf,
 				size_t len, loff_t *ppos)
 {
 	u32	m = iminor(file->f_dentry->d_inode);
@@ -147,7 +147,7 @@
 	return count;
 }
 
-static int cs5535_gpio_open(struct inode *inode, struct file *file)
+int cs5535_gpio_open(struct inode *inode, struct file *file)
 {
 	u32 m = iminor(inode);
 
@@ -158,14 +158,14 @@
 	return nonseekable_open(inode, file);
 }
 
-static const struct file_operations cs5535_gpio_fops = {
+const struct file_operations cs5535_gpio_fops = {
 	.owner	= THIS_MODULE,
 	.write	= cs5535_gpio_write,
 	.read	= cs5535_gpio_read,
 	.open	= cs5535_gpio_open
 };
 
-static int __init cs5535_gpio_init(void)
+int __init cs5535_gpio_init(void)
 {
 	dev_t	dev_id;
 	u32	low, hi;
@@ -238,7 +238,7 @@
 	return 0;
 }
 
-static void __exit cs5535_gpio_cleanup(void)
+void __exit cs5535_gpio_cleanup(void)
 {
 	dev_t dev_id = MKDEV(major, 0);
 
diff -urN -xcprover cproverbm.GKAExt/drivers/char/ds1286.c linux-2.6.19-ddverify-seq1/drivers/char/ds1286.c
--- cproverbm.GKAExt/drivers/char/ds1286.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/ds1286.c	2011-01-12 13:39:08.000000000 +0000
@@ -52,25 +52,25 @@
  *	ioctls.
  */
 
-static DECLARE_WAIT_QUEUE_HEAD(ds1286_wait);
+DECLARE_WAIT_QUEUE_HEAD(ds1286_wait);
 
-static ssize_t ds1286_read(struct file *file, char *buf,
+ssize_t ds1286_read(struct file *file, char *buf,
 			size_t count, loff_t *ppos);
 
-static int ds1286_ioctl(struct inode *inode, struct file *file,
+int ds1286_ioctl(struct inode *inode, struct file *file,
                         unsigned int cmd, unsigned long arg);
 
-static unsigned int ds1286_poll(struct file *file, poll_table *wait);
+unsigned int ds1286_poll(struct file *file, poll_table *wait);
 
-static void ds1286_get_alm_time (struct rtc_time *alm_tm);
-static void ds1286_get_time(struct rtc_time *rtc_tm);
-static int ds1286_set_time(struct rtc_time *rtc_tm);
+void ds1286_get_alm_time (struct rtc_time *alm_tm);
+void ds1286_get_time(struct rtc_time *rtc_tm);
+int ds1286_set_time(struct rtc_time *rtc_tm);
 
-static inline unsigned char ds1286_is_updating(void);
+inline unsigned char ds1286_is_updating(void);
 
-static DEFINE_SPINLOCK(ds1286_lock);
+DEFINE_SPINLOCK(ds1286_lock);
 
-static int ds1286_read_proc(char *page, char **start, off_t off,
+int ds1286_read_proc(char *page, char **start, off_t off,
                             int count, int *eof, void *data);
 
 /*
@@ -80,9 +80,9 @@
 #define RTC_IS_OPEN		0x01	/* means /dev/rtc is in use	*/
 #define RTC_TIMER_ON		0x02	/* missed irq timer active	*/
 
-static unsigned char ds1286_status;	/* bitmapped status byte.	*/
+unsigned char ds1286_status;	/* bitmapped status byte.	*/
 
-static unsigned char days_in_mo[] = {
+unsigned char days_in_mo[] = {
 	0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
 };
 
@@ -90,13 +90,13 @@
  *	Now all the various file operations that we export.
  */
 
-static ssize_t ds1286_read(struct file *file, char *buf,
+ssize_t ds1286_read(struct file *file, char *buf,
                            size_t count, loff_t *ppos)
 {
 	return -EIO;
 }
 
-static int ds1286_ioctl(struct inode *inode, struct file *file,
+int ds1286_ioctl(struct inode *inode, struct file *file,
                         unsigned int cmd, unsigned long arg)
 {
 	struct rtc_time wtime;
@@ -246,7 +246,7 @@
  *	up things on a close.
  */
 
-static int ds1286_open(struct inode *inode, struct file *file)
+int ds1286_open(struct inode *inode, struct file *file)
 {
 	spin_lock_irq(&ds1286_lock);
 
@@ -263,14 +263,14 @@
 	return -EBUSY;
 }
 
-static int ds1286_release(struct inode *inode, struct file *file)
+int ds1286_release(struct inode *inode, struct file *file)
 {
 	ds1286_status &= ~RTC_IS_OPEN;
 
 	return 0;
 }
 
-static unsigned int ds1286_poll(struct file *file, poll_table *wait)
+unsigned int ds1286_poll(struct file *file, poll_table *wait)
 {
 	poll_wait(file, &ds1286_wait, wait);
 
@@ -281,7 +281,7 @@
  *	The various file operations we support.
  */
 
-static const struct file_operations ds1286_fops = {
+const struct file_operations ds1286_fops = {
 	.llseek		= no_llseek,
 	.read		= ds1286_read,
 	.poll		= ds1286_poll,
@@ -290,14 +290,14 @@
 	.release	= ds1286_release,
 };
 
-static struct miscdevice ds1286_dev=
+struct miscdevice ds1286_dev=
 {
 	.minor	= RTC_MINOR,
 	.name	= "rtc",
 	.fops	= &ds1286_fops,
 };
 
-static int __init ds1286_init(void)
+int __init ds1286_init(void)
 {
 	int err;
 
@@ -322,20 +322,20 @@
 	return err;
 }
 
-static void __exit ds1286_exit(void)
+void __exit ds1286_exit(void)
 {
 	remove_proc_entry("driver/rtc", NULL);
 	misc_deregister(&ds1286_dev);
 }
 
-static char *days[] = {
+char *days[] = {
 	"***", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
 };
 
 /*
  *	Info exported via "/proc/rtc".
  */
-static int ds1286_proc_output(char *buf)
+int ds1286_proc_output(char *buf)
 {
 	char *p, *s;
 	struct rtc_time tm;
@@ -407,7 +407,7 @@
 	return  p - buf;
 }
 
-static int ds1286_read_proc(char *page, char **start, off_t off,
+int ds1286_read_proc(char *page, char **start, off_t off,
                          int count, int *eof, void *data)
 {
 	int len = ds1286_proc_output (page);
@@ -425,13 +425,13 @@
 /*
  * Returns true if a clock update is in progress
  */
-static inline unsigned char ds1286_is_updating(void)
+inline unsigned char ds1286_is_updating(void)
 {
 	return rtc_read(RTC_CMD) & RTC_TE;
 }
 
 
-static void ds1286_get_time(struct rtc_time *rtc_tm)
+void ds1286_get_time(struct rtc_time *rtc_tm)
 {
 	unsigned char save_control;
 	unsigned long flags;
@@ -490,7 +490,7 @@
 	rtc_tm->tm_mon--;
 }
 
-static int ds1286_set_time(struct rtc_time *rtc_tm)
+int ds1286_set_time(struct rtc_time *rtc_tm)
 {
 	unsigned char mon, day, hrs, min, sec, leap_yr;
 	unsigned char save_control;
@@ -550,7 +550,7 @@
 	return 0;
 }
 
-static void ds1286_get_alm_time(struct rtc_time *alm_tm)
+void ds1286_get_alm_time(struct rtc_time *alm_tm)
 {
 	unsigned char cmd;
 	unsigned long flags;
diff -urN -xcprover cproverbm.GKAExt/drivers/char/dtlk.c linux-2.6.19-ddverify-seq1/drivers/char/dtlk.c
--- cproverbm.GKAExt/drivers/char/dtlk.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/dtlk.c	2011-01-12 13:39:08.000000000 +0000
@@ -73,28 +73,28 @@
 #endif				/* TRACING */
 
 
-static int dtlk_major;
-static int dtlk_port_lpc;
-static int dtlk_port_tts;
-static int dtlk_busy;
-static int dtlk_has_indexing;
-static unsigned int dtlk_portlist[] =
+int dtlk_major;
+int dtlk_port_lpc;
+int dtlk_port_tts;
+int dtlk_busy;
+int dtlk_has_indexing;
+unsigned int dtlk_portlist[] =
 {0x25e, 0x29e, 0x2de, 0x31e, 0x35e, 0x39e, 0};
-static wait_queue_head_t dtlk_process_list;
-static struct timer_list dtlk_timer;
+wait_queue_head_t dtlk_process_list;
+struct timer_list dtlk_timer;
 
 /* prototypes for file_operations struct */
-static ssize_t dtlk_read(struct file *, char __user *,
+ssize_t dtlk_read(struct file *, char __user *,
 			 size_t nbytes, loff_t * ppos);
-static ssize_t dtlk_write(struct file *, const char __user *,
-			  size_t nbytes, loff_t * ppos);
-static unsigned int dtlk_poll(struct file *, poll_table *);
-static int dtlk_open(struct inode *, struct file *);
-static int dtlk_release(struct inode *, struct file *);
-static int dtlk_ioctl(struct inode *inode, struct file *file,
+ssize_t dtlk_write(struct file *, const char __user *,
+		   size_t nbytes, loff_t * ppos);
+unsigned int dtlk_poll(struct file *, poll_table *);
+int dtlk_open(struct inode *, struct file *);
+int dtlk_release(struct inode *, struct file *);
+int dtlk_ioctl(struct inode *inode, struct file *file,
 		      unsigned int cmd, unsigned long arg);
 
-static const struct file_operations dtlk_fops =
+const struct file_operations dtlk_fops =
 {
 	.owner		= THIS_MODULE,
 	.read		= dtlk_read,
@@ -106,20 +106,20 @@
 };
 
 /* local prototypes */
-static int dtlk_dev_probe(void);
-static struct dtlk_settings *dtlk_interrogate(void);
-static int dtlk_readable(void);
-static char dtlk_read_lpc(void);
-static char dtlk_read_tts(void);
-static int dtlk_writeable(void);
-static char dtlk_write_bytes(const char *buf, int n);
-static char dtlk_write_tts(char);
+int dtlk_dev_probe(void);
+struct dtlk_settings *dtlk_interrogate(void);
+int dtlk_readable(void);
+char dtlk_read_lpc(void);
+char dtlk_read_tts(void);
+int dtlk_writeable(void);
+char dtlk_write_bytes(const char *buf, int n);
+char dtlk_write_tts(char);
 /*
    static void dtlk_handle_error(char, char, unsigned int);
  */
-static void dtlk_timer_tick(unsigned long data);
+void dtlk_timer_tick(unsigned long data);
 
-static ssize_t dtlk_read(struct file *file, char __user *buf,
+ssize_t dtlk_read(struct file *file, char __user *buf,
 			 size_t count, loff_t * ppos)
 {
 	unsigned int minor = iminor(file->f_dentry->d_inode);
@@ -152,7 +152,7 @@
 	return -EAGAIN;
 }
 
-static ssize_t dtlk_write(struct file *file, const char __user *buf,
+ssize_t dtlk_write(struct file *file, const char __user *buf,
 			  size_t count, loff_t * ppos)
 {
 	int i = 0, retries = 0, ch;
@@ -225,7 +225,7 @@
 	return -EAGAIN;
 }
 
-static unsigned int dtlk_poll(struct file *file, poll_table * wait)
+unsigned int dtlk_poll(struct file *file, poll_table * wait)
 {
 	int mask = 0;
 	unsigned long expires;
@@ -256,13 +256,13 @@
 	return mask;
 }
 
-static void dtlk_timer_tick(unsigned long data)
+void dtlk_timer_tick(unsigned long data)
 {
 	TRACE_TEXT(" dtlk_timer_tick");
 	wake_up_interruptible(&dtlk_process_list);
 }
 
-static int dtlk_ioctl(struct inode *inode,
+int dtlk_ioctl(struct inode *inode,
 		      struct file *file,
 		      unsigned int cmd,
 		      unsigned long arg)
@@ -289,7 +289,7 @@
 	}
 }
 
-static int dtlk_open(struct inode *inode, struct file *file)
+int dtlk_open(struct inode *inode, struct file *file)
 {
 	TRACE_TEXT("(dtlk_open");
 
@@ -305,7 +305,7 @@
 	}
 }
 
-static int dtlk_release(struct inode *inode, struct file *file)
+int dtlk_release(struct inode *inode, struct file *file)
 {
 	TRACE_TEXT("(dtlk_release");
 
@@ -323,7 +323,7 @@
 	return 0;
 }
 
-static int __init dtlk_init(void)
+int __init dtlk_init(void)
 {
 	dtlk_port_lpc = 0;
 	dtlk_port_tts = 0;
@@ -343,7 +343,7 @@
 	return 0;
 }
 
-static void __exit dtlk_cleanup (void)
+void __exit dtlk_cleanup (void)
 {
 	dtlk_write_bytes("goodbye", 8);
 	msleep_interruptible(500);		/* nap 0.50 sec but
@@ -361,7 +361,7 @@
 
 /* ------------------------------------------------------------------------ */
 
-static int dtlk_readable(void)
+int dtlk_readable(void)
 {
 #ifdef TRACING
 	printk(" dtlk_readable=%u@%u", inb_p(dtlk_port_lpc) != 0x7f, jiffies);
@@ -369,7 +369,7 @@
 	return inb_p(dtlk_port_lpc) != 0x7f;
 }
 
-static int dtlk_writeable(void)
+int dtlk_writeable(void)
 {
 	/* TRACE_TEXT(" dtlk_writeable"); */
 #ifdef TRACINGMORE
@@ -378,7 +378,7 @@
 	return inb_p(dtlk_port_tts) & TTS_WRITABLE;
 }
 
-static int __init dtlk_dev_probe(void)
+int __init dtlk_dev_probe(void)
 {
 	unsigned int testval = 0;
 	int i = 0;
@@ -499,7 +499,7 @@
  */
 
 /* interrogate the DoubleTalk PC and return its settings */
-static struct dtlk_settings *dtlk_interrogate(void)
+struct dtlk_settings *dtlk_interrogate(void)
 {
 	unsigned char *t;
 	static char buf[sizeof(struct dtlk_settings) + 1];
@@ -554,7 +554,7 @@
 	return &status;
 }
 
-static char dtlk_read_tts(void)
+char dtlk_read_tts(void)
 {
 	int portval, retries = 0;
 	char ch;
@@ -584,7 +584,7 @@
 	return ch;
 }
 
-static char dtlk_read_lpc(void)
+char dtlk_read_lpc(void)
 {
 	int retries = 0;
 	char ch;
@@ -609,7 +609,7 @@
 }
 
 /* write n bytes to tts port */
-static char dtlk_write_bytes(const char *buf, int n)
+char dtlk_write_bytes(const char *buf, int n)
 {
 	char val = 0;
 	/*  printk("dtlk_write_bytes(\"%-*s\", %d)\n", n, buf, n); */
@@ -620,7 +620,7 @@
 	return val;
 }
 
-static char dtlk_write_tts(char ch)
+char dtlk_write_tts(char ch)
 {
 	int retries = 0;
 #ifdef TRACINGMORE
diff -urN -xcprover cproverbm.GKAExt/drivers/char/efirtc.c linux-2.6.19-ddverify-seq1/drivers/char/efirtc.c
--- cproverbm.GKAExt/drivers/char/efirtc.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/efirtc.c	2011-01-12 13:39:08.000000000 +0000
@@ -48,15 +48,15 @@
  */
 #define EFI_RTC_EPOCH		1998
 
-static DEFINE_SPINLOCK(efi_rtc_lock);
+DEFINE_SPINLOCK(efi_rtc_lock);
 
-static int efi_rtc_ioctl(struct inode *inode, struct file *file,
+int efi_rtc_ioctl(struct inode *inode, struct file *file,
 		     unsigned int cmd, unsigned long arg);
 
 #define is_leap(year) \
           ((year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))
 
-static const unsigned short int __mon_yday[2][13] =
+const unsigned short int __mon_yday[2][13] =
 {
 	/* Normal years.  */
 	{ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 },
@@ -67,7 +67,7 @@
 /*
  * returns day of the year [0-365]
  */
-static inline int
+inline int
 compute_yday(efi_time_t *eft)
 {
 	/* efi_time_t.month is in the [1-12] so, we need -1 */
@@ -78,7 +78,7 @@
  *
  * Don't try to provide a year that's before 1998, please !
  */
-static int
+int
 compute_wday(efi_time_t *eft)
 {
 	int y;
@@ -100,7 +100,7 @@
 	return (ndays + 4) % 7;
 }
 
-static void
+void
 convert_to_efi_time(struct rtc_time *wtime, efi_time_t *eft)
 {
 
@@ -115,7 +115,7 @@
 	eft->timezone	= EFI_UNSPECIFIED_TIMEZONE;
 }
 
-static void
+void
 convert_from_efi_time(efi_time_t *eft, struct rtc_time *wtime)
 {
 	memset(wtime, 0, sizeof(*wtime));
@@ -145,7 +145,7 @@
 	}
 }
 
-static int
+int
 efi_rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
 		     unsigned long arg)
 {
@@ -264,7 +264,7 @@
  *	up things on a close.
  */
 
-static int
+int
 efi_rtc_open(struct inode *inode, struct file *file)
 {
 	/*
@@ -275,7 +275,7 @@
 	return 0;
 }
 
-static int
+int
 efi_rtc_close(struct inode *inode, struct file *file)
 {
 	return 0;
@@ -285,14 +285,14 @@
  *	The various file operations we support.
  */
 
-static const struct file_operations efi_rtc_fops = {
+const struct file_operations efi_rtc_fops = {
 	.owner		= THIS_MODULE,
 	.ioctl		= efi_rtc_ioctl,
 	.open		= efi_rtc_open,
 	.release	= efi_rtc_close,
 };
 
-static struct miscdevice efi_rtc_dev=
+struct miscdevice efi_rtc_dev=
 {
 	EFI_RTC_MINOR,
 	"efirtc",
@@ -302,7 +302,7 @@
 /*
  *	We export RAW EFI information to /proc/driver/efirtc
  */
-static int
+int
 efi_rtc_get_status(char *buf)
 {
 	efi_time_t 	eft, alm;
@@ -367,7 +367,7 @@
 	return  p - buf;
 }
 
-static int
+int
 efi_rtc_read_proc(char *page, char **start, off_t off,
                                  int count, int *eof, void *data)
 {
@@ -380,7 +380,7 @@
         return len;
 }
 
-static int __init 
+int __init 
 efi_rtc_init(void)
 {
 	int ret;
@@ -405,7 +405,7 @@
 	return 0;
 }
 
-static void __exit
+void __exit
 efi_rtc_exit(void)
 {
 	/* not yet used */
diff -urN -xcprover cproverbm.GKAExt/drivers/char/generic_nvram.c linux-2.6.19-ddverify-seq1/drivers/char/generic_nvram.c
--- cproverbm.GKAExt/drivers/char/generic_nvram.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/generic_nvram.c	2011-01-12 13:39:08.000000000 +0000
@@ -28,7 +28,7 @@
 
 #define NVRAM_SIZE	8192
 
-static loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
+loff_t nvram_llseek(struct file *file, loff_t offset, int origin)
 {
 	lock_kernel();
 	switch (origin) {
@@ -48,7 +50,7 @@
 	return file->f_pos;
 }
 
-static ssize_t read_nvram(struct file *file, char __user *buf,
+ssize_t read_nvram(struct file *file, char __user *buf,
 			  size_t count, loff_t *ppos)
 {
 	unsigned int i;
@@ -65,7 +67,7 @@
 	return p - buf;
 }
 
-static ssize_t write_nvram(struct file *file, const char __user *buf,
+ssize_t write_nvram(struct file *file, const char __user *buf,
 			   size_t count, loff_t *ppos)
 {
 	unsigned int i;
@@ -85,7 +87,7 @@
 	return p - buf;
 }
 
-static int nvram_ioctl(struct inode *inode, struct file *file,
+int nvram_ioctl(struct inode *inode, struct file *file,
 	unsigned int cmd, unsigned long arg)
 {
 	switch(cmd) {
@@ -125,7 +127,7 @@
 	.ioctl		= nvram_ioctl,
 };
 
-static struct miscdevice nvram_dev = {
+struct miscdevice nvram_dev = {
 	NVRAM_MINOR,
 	"nvram",
 	&nvram_fops
diff -urN -xcprover cproverbm.GKAExt/drivers/char/genrtc.c linux-2.6.19-ddverify-seq1/drivers/char/genrtc.c
--- cproverbm.GKAExt/drivers/char/genrtc.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/genrtc.c	2011-01-12 13:39:08.000000000 +0000
@@ -64,7 +64,7 @@
  *	ioctls.
  */
 
-static DECLARE_WAIT_QUEUE_HEAD(gen_rtc_wait);
+DECLARE_WAIT_QUEUE_HEAD(gen_rtc_wait);
 
 /*
  *	Bits in gen_rtc_status.
@@ -72,37 +72,37 @@
 
 #define RTC_IS_OPEN		0x01	/* means /dev/rtc is in use	*/
 
-static unsigned char gen_rtc_status;	/* bitmapped status byte.	*/
-static unsigned long gen_rtc_irq_data;	/* our output to the world	*/
+unsigned char gen_rtc_status;	/* bitmapped status byte.	*/
+unsigned long gen_rtc_irq_data;	/* our output to the world	*/
 
 /* months start at 0 now */
-static unsigned char days_in_mo[] =
+unsigned char days_in_mo[] =
 {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
 
-static int irq_active;
+int irq_active;
 
 #ifdef CONFIG_GEN_RTC_X
-static struct work_struct genrtc_task;
-static struct timer_list timer_task;
+struct work_struct genrtc_task;
+struct timer_list timer_task;
 
-static unsigned int oldsecs;
-static int lostint;
-static unsigned long tt_exp;
+unsigned int oldsecs;
+int lostint;
+unsigned long tt_exp;
 
-static void gen_rtc_timer(unsigned long data);
+void gen_rtc_timer(unsigned long data);
 
-static volatile int stask_active;              /* schedule_work */
-static volatile int ttask_active;              /* timer_task */
-static int stop_rtc_timers;                    /* don't requeue tasks */
-static DEFINE_SPINLOCK(gen_rtc_lock);
+volatile int stask_active;              /* schedule_work */
+volatile int ttask_active;              /* timer_task */
+int stop_rtc_timers;                    /* don't requeue tasks */
+DEFINE_SPINLOCK(gen_rtc_lock);
 
-static void gen_rtc_interrupt(unsigned long arg);
+void gen_rtc_interrupt(unsigned long arg);
 
 /*
  * Routine to poll RTC seconds field for change as often as possible,
  * after first RTC_UIE use timer to reduce polling
  */
-static void genrtc_troutine(void *data)
+void genrtc_troutine(void *data)
 {
 	unsigned int tmp = get_rtc_ss();
 	
@@ -126,7 +126,7 @@
 		stask_active = 0;
 }
 
-static void gen_rtc_timer(unsigned long data)
+void gen_rtc_timer(unsigned long data)
 {
 	lostint = get_rtc_ss() - oldsecs ;
 	if (lostint<0) 
@@ -147,7 +147,7 @@
  * from some routine that periodically (eg 100HZ) monitors
  * whether RTC_SECS changed
  */
-static void gen_rtc_interrupt(unsigned long arg)
+void gen_rtc_interrupt(unsigned long arg)
 {
 	/*  We store the status in the low byte and the number of
 	 *	interrupts received since the last read in the remainder
@@ -170,7 +170,7 @@
 /*
  *	Now all the various file operations that we export.
  */
-static ssize_t gen_rtc_read(struct file *file, char __user *buf,
+ssize_t gen_rtc_read(struct file *file, char __user *buf,
 			size_t count, loff_t *ppos)
 {
 	DECLARE_WAITQUEUE(wait, current);
@@ -213,7 +215,7 @@
 	return retval;
 }
 
-static unsigned int gen_rtc_poll(struct file *file,
+unsigned int gen_rtc_poll(struct file *file,
 				 struct poll_table_struct *wait)
 {
 	poll_wait(file, &gen_rtc_wait, wait);
@@ -230,7 +232,7 @@
  * meddles with the interrupt enable/disable bits.
  */
 
-static inline void gen_clear_rtc_irq_bit(unsigned char bit)
+inline void gen_clear_rtc_irq_bit(unsigned char bit)
 {
 #ifdef CONFIG_GEN_RTC_X
 	stop_rtc_timers = 1;
@@ -247,7 +249,7 @@
 #endif
 }
 
-static inline int gen_set_rtc_irq_bit(unsigned char bit)
+inline int gen_set_rtc_irq_bit(unsigned char bit)
 {
 #ifdef CONFIG_GEN_RTC_X
 	spin_lock(&gen_rtc_lock);
@@ -272,7 +274,7 @@
 #endif
 }
 
-static int gen_rtc_ioctl(struct inode *inode, struct file *file,
+int gen_rtc_ioctl(struct inode *inode, struct file *file,
 			 unsigned int cmd, unsigned long arg)
 {
 	struct rtc_time wtime;
@@ -348,7 +350,7 @@
  *	up things on a close.
  */
 
-static int gen_rtc_open(struct inode *inode, struct file *file)
+int gen_rtc_open(struct inode *inode, struct file *file)
 {
 	if (gen_rtc_status & RTC_IS_OPEN)
 		return -EBUSY;
@@ -360,7 +362,7 @@
 	return 0;
 }
 
-static int gen_rtc_release(struct inode *inode, struct file *file)
+int gen_rtc_release(struct inode *inode, struct file *file)
 {
 	/*
 	 * Turn off all interrupts once the device is no longer
@@ -380,7 +382,7 @@
  *	Info exported via "/proc/rtc".
  */
 
-static int gen_rtc_proc_output(char *buf)
+int gen_rtc_proc_output(char *buf)
 {
 	char *p;
 	struct rtc_time tm;
@@ -452,7 +454,7 @@
 	return p - buf;
 }
 
-static int gen_rtc_read_proc(char *page, char **start, off_t off,
+int gen_rtc_read_proc(char *page, char **start, off_t off,
 			     int count, int *eof, void *data)
 {
 	int len = gen_rtc_proc_output (page);
@@ -464,7 +466,7 @@
 	return len;
 }
 
-static int __init gen_rtc_proc_init(void)
+int __init gen_rtc_proc_init(void)
 {
 	struct proc_dir_entry *r;
 
@@ -474,7 +476,7 @@
 	return 0;
 }
 #else
-static inline int gen_rtc_proc_init(void) { return 0; }
+inline int gen_rtc_proc_init(void) { return 0; }
 #endif /* CONFIG_PROC_FS */
 
 
@@ -482,7 +484,7 @@
  *	The various file operations we support.
  */
 
-static const struct file_operations gen_rtc_fops = {
+const struct file_operations gen_rtc_fops = {
 	.owner		= THIS_MODULE,
 #ifdef CONFIG_GEN_RTC_X
 	.read		= gen_rtc_read,
@@ -493,14 +495,14 @@
 	.release	= gen_rtc_release,
 };
 
-static struct miscdevice rtc_gen_dev =
+struct miscdevice rtc_gen_dev =
 {
 	.minor		= RTC_MINOR,
 	.name		= "rtc",
 	.fops		= &gen_rtc_fops,
 };
 
-static int __init rtc_generic_init(void)
+int __init rtc_generic_init(void)
 {
 	int retval;
 
@@ -519,7 +521,7 @@
 	return 0;
 }
 
-static void __exit rtc_generic_exit(void)
+void __exit rtc_generic_exit(void)
 {
 	remove_proc_entry ("driver/rtc", NULL);
 	misc_deregister(&rtc_gen_dev);
diff -urN -xcprover cproverbm.GKAExt/drivers/char/nwbutton.c linux-2.6.19-ddverify-seq1/drivers/char/nwbutton.c
--- cproverbm.GKAExt/drivers/char/nwbutton.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/nwbutton.c	2011-01-12 13:04:28.000000000 +0000
@@ -23,15 +23,15 @@
 #define __NWBUTTON_C		/* Tell the header file who we are */
 #include "nwbutton.h"
 
-static int button_press_count;		/* The count of button presses */
-static struct timer_list button_timer;	/* Times for the end of a sequence */ 
-static DECLARE_WAIT_QUEUE_HEAD(button_wait_queue); /* Used for blocking read */
-static char button_output_buffer[32];	/* Stores data to write out of device */
-static int bcount;			/* The number of bytes in the buffer */
-static int bdelay = BUTTON_DELAY;	/* The delay, in jiffies */
-static struct button_callback button_callback_list[32]; /* The callback list */
-static int callback_count;		/* The number of callbacks registered */
-static int reboot_count = NUM_PRESSES_REBOOT; /* Number of presses to reboot */
+int button_press_count;		/* The count of button presses */
+struct timer_list button_timer;	/* Times for the end of a sequence */ 
+DECLARE_WAIT_QUEUE_HEAD(button_wait_queue); /* Used for blocking read */
+char button_output_buffer[32];	/* Stores data to write out of device */
+int bcount;			/* The number of bytes in the buffer */
+int bdelay = BUTTON_DELAY;	/* The delay, in jiffies */
+struct button_callback button_callback_list[32]; /* The callback list */
+int callback_count;		/* The number of callbacks registered */
+int reboot_count = NUM_PRESSES_REBOOT; /* Number of presses to reboot */
 
 /*
  * This function is called by other drivers to register a callback function
@@ -104,7 +105,7 @@
  * pointer (which should never happen anyway).
  */
 
-static void button_consume_callbacks (int bpcount)
+void button_consume_callbacks (int bpcount)
 {
 	int lp = 0;
 	for (; lp <= 31; lp++) {
@@ -124,7 +125,7 @@
  * any matching registered function callbacks, initiate reboot, etc.).
  */
 
-static void button_sequence_finished (unsigned long parameters)
+void button_sequence_finished (unsigned long parameters)
 {
 #ifdef CONFIG_NWBUTTON_REBOOT		/* Reboot using button is enabled */
 	if (button_press_count == reboot_count)
@@ -144,7 +145,7 @@
  *  increments the counter.
  */ 
 
-static irqreturn_t button_handler (int irq, void *dev_id)
+irqreturn_t button_handler (int irq, void *dev_id)
 {
 	if (button_press_count) {
 		del_timer (&button_timer);
@@ -168,7 +169,7 @@
  * device at any one time.
  */
 
-static int button_read (struct file *filp, char __user *buffer,
+int button_read (struct file *filp, char __user *buffer,
 			size_t count, loff_t *ppos)
 {
 	interruptible_sleep_on (&button_wait_queue);
@@ -182,7 +183,7 @@
  * attempts to perform these operations on the device.
  */
 
-static const struct file_operations button_fops = {
+const struct file_operations button_fops = {
 	.owner		= THIS_MODULE,
 	.read		= button_read,
 };
@@ -193,7 +194,7 @@
  * and the address of the above file operations structure.
  */
 
-static struct miscdevice button_misc_device = {
+struct miscdevice button_misc_device = {
 	BUTTON_MINOR,
 	"nwbutton",
 	&button_fops,
@@ -208,7 +209,7 @@
  * this driver.
  */
 
-static int __init nwbutton_init(void)
+int __init nwbutton_init(void)
 {
 	if (!machine_is_netwinder())
 		return -ENODEV;
@@ -232,7 +233,7 @@
 	return 0;
 }
 
-static void __exit nwbutton_exit (void) 
+void __exit nwbutton_exit (void) 
 {
 	free_irq (IRQ_NETWINDER_BUTTON, NULL);
 	misc_deregister (&button_misc_device);
diff -urN -xcprover cproverbm.GKAExt/drivers/char/nwbutton.h linux-2.6.19-ddverify-seq1/drivers/char/nwbutton.h
--- cproverbm.GKAExt/drivers/char/nwbutton.h	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/nwbutton.h	2011-01-12 13:04:28.000000000 +0000
@@ -24,12 +24,12 @@
 
 /* Function prototypes: */
 
-static void button_sequence_finished (unsigned long parameters);
-static irqreturn_t button_handler (int irq, void *dev_id);
+void button_sequence_finished (unsigned long parameters);
+irqreturn_t button_handler (int irq, void *dev_id);
 int button_init (void);
 int button_add_callback (void (*callback) (void), int count);
 int button_del_callback (void (*callback) (void));
-static void button_consume_callbacks (int bpcount);
+void button_consume_callbacks (int bpcount);
 
 #else /* Not compiling the driver itself */
 
diff -urN -xcprover cproverbm.GKAExt/drivers/char/toshiba.c linux-2.6.19-ddverify-seq1/drivers/char/toshiba.c
--- cproverbm.GKAExt/drivers/char/toshiba.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/toshiba.c	2011-01-12 13:39:08.000000000 +0000
@@ -78,26 +78,26 @@
 MODULE_DESCRIPTION("Toshiba laptop SMM driver");
 MODULE_SUPPORTED_DEVICE("toshiba");
 
-static int tosh_fn;
+int tosh_fn;
 module_param_named(fn, tosh_fn, int, 0);
 MODULE_PARM_DESC(fn, "User specified Fn key detection port");
 
-static int tosh_id;
-static int tosh_bios;
-static int tosh_date;
-static int tosh_sci;
-static int tosh_fan;
+int tosh_id;
+int tosh_bios;
+int tosh_date;
+int tosh_sci;
+int tosh_fan;
 
-static int tosh_ioctl(struct inode *, struct file *, unsigned int,
+int tosh_ioctl(struct inode *, struct file *, unsigned int,
 	unsigned long);
 
 
-static const struct file_operations tosh_fops = {
+const struct file_operations tosh_fops = {
 	.owner		= THIS_MODULE,
 	.ioctl		= tosh_ioctl,
 };
 
-static struct miscdevice tosh_device = {
+struct miscdevice tosh_device = {
 	TOSH_MINOR_DEV,
 	"toshiba",
 	&tosh_fops
@@ -107,7 +107,7 @@
  * Read the Fn key status
  */
 #ifdef CONFIG_PROC_FS
-static int tosh_fn_status(void)
+int tosh_fn_status(void)
 {
         unsigned char scan;
 	unsigned long flags;
@@ -129,7 +129,7 @@
 /*
  * For the Portage 610CT and the Tecra 700CS/700CDT emulate the HCI fan function
  */
-static int tosh_emulate_fan(SMMRegisters *regs)
+int tosh_emulate_fan(SMMRegisters *regs)
 {
 	unsigned long eax,ecx,flags;
 	unsigned char al;
@@ -251,7 +251,7 @@
 }
 
 
-static int tosh_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
+int tosh_ioctl(struct inode *ip, struct file *fp, unsigned int cmd,
 	unsigned long arg)
 {
 	SMMRegisters regs;
@@ -297,7 +297,7 @@
  * Print the information for /proc/toshiba
  */
 #ifdef CONFIG_PROC_FS
-static int tosh_get_info(char *buffer, char **start, off_t fpos, int length)
+int tosh_get_info(char *buffer, char **start, off_t fpos, int length)
 {
 	char *temp;
 	int key;
@@ -331,7 +331,7 @@
 /*
  * Determine which port to use for the Fn key status
  */
-static void tosh_set_fn_port(void)
+void tosh_set_fn_port(void)
 {
 	switch (tosh_id) {
 		case 0xfc02: case 0xfc04: case 0xfc09: case 0xfc0a: case 0xfc10:
@@ -355,7 +355,7 @@
 /*
  * Get the machine identification number of the current model
  */
-static int tosh_get_machine_id(void __iomem *bios)
+int tosh_get_machine_id(void __iomem *bios)
 {
 	int id;
 	SMMRegisters regs;
@@ -411,7 +411,7 @@
  *   laptop, otherwise zero and determines the Machine ID, BIOS version and
  *   date, and SCI version.
  */
-static int tosh_probe(void)
+int tosh_probe(void)
 {
 	int i,major,minor,day,year,month,flag;
 	unsigned char signature[7] = { 0x54,0x4f,0x53,0x48,0x49,0x42,0x41 };
@@ -487,7 +487,7 @@
 	return 0;
 }
 
-static int __init toshiba_init(void)
+int __init toshiba_init(void)
 {
 	int retval;
 	/* are we running on a Toshiba laptop */
@@ -517,7 +517,7 @@
 	return 0;
 }
 
-static void __exit toshiba_exit(void)
+void __exit toshiba_exit(void)
 {
 	remove_proc_entry("toshiba", NULL);
 	misc_deregister(&tosh_device);
diff -urN -xcprover cproverbm.GKAExt/drivers/char/watchdog/pcwd.c linux-2.6.19-ddverify-seq1/drivers/char/watchdog/pcwd.c
--- cproverbm.GKAExt/drivers/char/watchdog/pcwd.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/watchdog/pcwd.c	2011-01-12 13:39:08.000000000 +0000
@@ -334,7 +334,7 @@
 		printk(KERN_INFO PFX "No previous trip detected - Cold boot or reset\n");
 }
 
-static void pcwd_timer_ping(unsigned long data)
+void pcwd_timer_ping(unsigned long data)
 {
 	int wdrst_stat;
 
diff -urN -xcprover cproverbm.GKAExt/drivers/char/watchdog/pcwd_pci.c linux-2.6.19-ddverify-seq1/drivers/char/watchdog/pcwd_pci.c
--- cproverbm.GKAExt/drivers/char/watchdog/pcwd_pci.c	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/drivers/char/watchdog/pcwd_pci.c	2011-01-12 13:05:03.000000000 +0000
@@ -661,7 +661,7 @@
  *	Init & exit routines
  */
 
-static int __devinit pcipcwd_card_init(struct pci_dev *pdev,
+int __devinit pcipcwd_card_init(struct pci_dev *pdev,
 		const struct pci_device_id *ent)
 {
 	int ret = -EIO;
diff -urN -xcprover cproverbm.GKAExt/include/linux/cdrom.h linux-2.6.19-ddverify-seq1/include/linux/cdrom.h
--- cproverbm.GKAExt/include/linux/cdrom.h	2006-11-29 21:57:37.000000000 +0000
+++ linux-2.6.19-ddverify-seq1/include/linux/cdrom.h	2011-01-12 13:04:09.000000000 +0000
@@ -749,7 +750,7 @@
 #define MRW_MODE_PC			0x03
 
 struct mrw_feature_desc {
-	__be16 feature_code;
+	__u16 feature_code;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1		: 2;
 	__u8 feature_version	: 4;
@@ -776,7 +777,7 @@
 
 /* cf. mmc4r02g.pdf 5.3.10 Random Writable Feature (0020h) pg 197 of 635 */
 struct rwrt_feature_desc {
-	__be16 feature_code;
+	__u16 feature_code;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1		: 2;
 	__u8 feature_version	: 4;
@@ -803,7 +804,7 @@
 };
 
 typedef struct {
-	__be16 disc_information_length;
+	__u16 disc_information_length;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 reserved1			: 3;
         __u8 erasable			: 1;
@@ -849,7 +850,7 @@
 } disc_information;
 
 typedef struct {
-	__be16 track_information_length;
+	__u16 track_information_length;
 	__u8 track_lsb;
 	__u8 session_lsb;
 	__u8 reserved1;
@@ -880,12 +881,12 @@
 	__u8 lra_v			: 1;
 	__u8 reserved3			: 6;
 #endif
-	__be32 track_start;
-	__be32 next_writable;
-	__be32 free_blocks;
-	__be32 fixed_packet_size;
-	__be32 track_size;
-	__be32 last_rec_address;
+	__u32 track_start;
+	__u32 next_writable;
+	__u32 free_blocks;
+	__u32 fixed_packet_size;
+	__u32 track_size;
+	__u32 last_rec_address;
 } track_information;
 
 struct feature_header {
@@ -896,12 +897,12 @@
 };
 
 struct mode_page_header {
-	__be16 mode_data_length;
+	__u16 mode_data_length;
 	__u8 medium_type;
 	__u8 reserved1;
 	__u8 reserved2;
 	__u8 reserved3;
-	__be16 desc_length;
+	__u16 desc_length;
 };
 
 #ifdef __KERNEL__
@@ -1106,7 +1109,7 @@
 #endif
 	__u8 session_format;
 	__u8 reserved6;
-	__be32 packet_size;
+	__u32 packet_size;
 	__u16 audio_pause;
 	__u8 mcn[16];
 	__u8 isrc[16];
@@ -1151,7 +1154,7 @@
 } rpc_state_t;
 
 struct event_header {
-	__be16 data_len;
+	__u16 data_len;
 #if defined(__BIG_ENDIAN_BITFIELD)
 	__u8 nea		: 1;
 	__u8 reserved1		: 4;
